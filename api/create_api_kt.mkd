Perfeito üëç
Aqui est√° o **passo a passo completo** baseado no artigo **‚ÄúKotlin - REST API completa com Spring Boot, Swagger, MySQL e Docker - Parte 01‚Äù** do Rafael Moura ‚Äî transformado em um **guia estruturado e execut√°vel**:

---

## üöÄ **1. Objetivo do Projeto**

Criar uma **API REST em Kotlin com Spring Boot**, documentada com **Swagger**, persistindo dados em um **banco MySQL** que roda em **Docker**.

---

## üß∞ **2. Preparar o Ambiente**

### ‚úÖ Requisitos

* **Docker e Docker Compose** instalados
* **IntelliJ IDEA** (ou sua IDE favorita)
* **JDK 17+**
* **Gradle** (caso n√£o use o wrapper)

---

## ‚öôÔ∏è **3. Criar o Projeto com Spring Initializr**

![texto](./img/springboot_create.png)

Acesse: [https://start.spring.io](https://start.spring.io)

**Configura√ß√µes:**

* **Project:** Gradle Project
* **Language:** Kotlin
* **Spring Boot:** vers√£o est√°vel (ex: `3.x`)
* **Packaging:** Jar
* **Java:** 17 ou 21

**Depend√™ncias:**

* Spring Web
* Spring Data JPA
* MySQL Driver
* Spring Boot Actuator

Clique em **Generate**, baixe o `.zip`, extraia e abra na sua IDE.

---

## üê≥ **4. Criar o `docker-compose.yml`**

Na **raiz do projeto**, crie o arquivo `docker-compose.yml`:

```yaml
version: '3.1'
services:
  db:
    container_name: mysql_local
    image: mysql:5.7
    volumes:
      - ./db:/var/lib/mysql
    environment:
      MYSQL_ALLOW_EMPTY_PASSWORD: "yes"
      MYSQL_ROOT_PASSWORD: "test"
      MYSQL_DATABASE: "crudexample"
      MYSQL_USER: "admin"
      MYSQL_PASSWORD: "test"
      MYSQL_ROOT_HOST: "%"
    ports:
      - "1000:3306"

```

### ‚ñ∂Ô∏è Subir o container

```bash
docker-compose up -d
```

### üîç Verificar se est√° rodando

```bash
docker ps
```

---

## ‚öôÔ∏è **5. Configurar o `application.yml`**

Substitua ou renomeie o arquivo `application.properties` por `application.yml` em
`src/main/resources/application.yml`:

```yaml
server:
  port: 8081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    initialization-mode: always
    password: test
    platform: mysql
    url: jdbc:mysql://localhost:1000/crudexample
    username: admin
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQLDialect
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    generate-ddl: true
    show-sql: true
    hibernate:
      ddl-auto: update
      naming-strategy: org.hibernate.cfg.ImprovedNamingStrategy
springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    try-it-out-enabled: true
    operations-sorter: method
    tags-sorter: alpha

```

---

## ‚ñ∂Ô∏è **6. Executar a Aplica√ß√£o**

Rode a classe principal `CrudexampleApplication.kt`:

üìç Caminho:
`src/main/kotlin/com/kotlin/crudexample/CrudexampleApplication.kt`

Ao rodar, voc√™ ver√° no log:

```
Started CrudexampleApplicationKt in X seconds (JVM running for X)
```

---

## ‚úÖ **7. Testar o Actuator**

Acesse no navegador:

```
http://localhost:8081/actuator
```

Deve retornar um JSON indicando o status da aplica√ß√£o (exemplo: `{"status":"UP"}`).

---

## üß© **8. Criar o Controller Inicial**

Crie o arquivo `ProductController.kt`:

üìç `src/main/kotlin/com/kotlin/crudexample/controller/ProductController.kt`

```kotlin
package com.kotlin.crudexample.controller

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class ProductController {

    @GetMapping("/products")
    fun getAll(): List<String> = listOf("product1", "product2")
}
```

---

## üåê **9. Testar Endpoint**

Execute novamente a aplica√ß√£o e acesse:

```
http://localhost:8081/products
```

Voc√™ deve ver o retorno:

```json
["product1", "product2"]
```

---

## ‚öôÔ∏è **10. Criar o modelo (Entity)**

üìÅ `src/main/kotlin/com/kotlin/crudexample/model/Product.kt`

```kotlin
package com.kotlin.crudexample.model

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "Product")
data class Product(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    val name: String
)
```

> ‚úÖ Usa `jakarta.persistence` (vers√£o compat√≠vel com Spring Boot 3+)
> ‚úÖ `data class` simplifica getters/setters/toString/equals automaticamente

---

## üß© **11. Criar o reposit√≥rio (Repository)**

üìÅ `src/main/kotlin/com/kotlin/crudexample/repository/ProductRepository.kt`

```kotlin
package com.kotlin.crudexample.repository

import com.kotlin.crudexample.model.Product
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface ProductRepository : JpaRepository<Product, Long>
```

> O Spring Data JPA gera todos os m√©todos CRUD automaticamente:
> `.findAll()`, `.save()`, `.deleteById()`, `.existsById()`, etc.

---

## üß† **12. Criar a interface do servi√ßo (Service)**

üìÅ `src/main/kotlin/com/kotlin/crudexample/service/ProductService.kt`

```kotlin
package com.kotlin.crudexample.service

import com.kotlin.crudexample.model.Product
import org.springframework.stereotype.Service

@Service
interface ProductService {
    fun getAll(): List<Product>
    fun getById(id: Long): Product
    fun create(product: Product): Product
    fun update(product: Product): String
    fun delete(id: Long): String
}
```

> Essa interface define as opera√ß√µes que o servi√ßo precisa oferecer.

---

## üí° **13. Implementar o servi√ßo**

üìÅ `src/main/kotlin/com/kotlin/crudexample/service/ProductServiceImpl.kt`

```kotlin
package com.kotlin.crudexample.service

import com.kotlin.crudexample.model.Product
import com.kotlin.crudexample.repository.ProductRepository
import org.springframework.stereotype.Service

@Service
class ProductServiceImpl(private val productRepository: ProductRepository) : ProductService {

    override fun getAll(): List<Product> = productRepository.findAll()

    override fun getById(id: Long): Product = productRepository.findById(id)
        .orElseThrow { NoSuchElementException("Produto com id $id n√£o encontrado") }

    override fun create(product: Product): Product = productRepository.save(product)

    override fun update(product: Product): String {
        if (!productRepository.existsById(product.id))
            return "Produto n√£o existe na base de dados"

        productRepository.save(product)
        return "Produto id ${product.id} alterado com sucesso"
    }

    override fun delete(id: Long): String {
        if (!productRepository.existsById(id))
            return "Produto n√£o existe na base de dados"

        productRepository.deleteById(id)
        return "Produto removido com sucesso!"
    }
}
```

> ‚ö†Ô∏è Aqui o `@Service` indica que o Spring gerencia essa classe como um bean,
> e a inje√ß√£o do `ProductRepository` √© feita via construtor (`private val`).

---

## üöÄ **14. Criar o controller REST**

üìÅ `src/main/kotlin/com/kotlin/crudexample/controller/ProductController.kt`

```kotlin
package com.kotlin.crudexample.controller

import com.kotlin.crudexample.model.Product
import com.kotlin.crudexample.service.ProductService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api")
class ProductController(private val productService: ProductService) {

    @GetMapping("/products")
    fun getAll(): List<Product> = productService.getAll()

    @GetMapping("/product/{id}")
    fun getById(@PathVariable id: Long): Product = productService.getById(id)

    @PostMapping("/product")
    fun create(@RequestBody product: Product): Product = productService.create(product)

    @PutMapping("/product")
    fun update(@RequestBody product: Product): String = productService.update(product)

    @DeleteMapping("/product/{id}")
    fun delete(@PathVariable id: Long): String = productService.delete(id)
}
```

> O controller agora apenas delega as opera√ß√µes ao service ‚Äî deixando a l√≥gica limpa.

---

## üß™ **15. Testar com o Postman**

### üîπ Endpoints:

| M√©todo   | Rota                | Descri√ß√£o                   |
| -------- | ------------------- | --------------------------- |
| `GET`    | `/api/products`     | Lista todos os produtos     |
| `GET`    | `/api/product/{id}` | Busca um produto espec√≠fico |
| `POST`   | `/api/product`      | Cria novo produto           |
| `PUT`    | `/api/product`      | Atualiza produto existente  |
| `DELETE` | `/api/product/{id}` | Remove produto              |

### üîπ Exemplo de JSON para `POST`:

```json
{
  "name": "Janela"
}
```

---

## ‚öôÔ∏è **16. Swagger UI (OpenAPI)**

Se voc√™ manteve a depend√™ncia:

```kotlin
implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
```

Acesse:

```
http://localhost:8081/swagger-ui/index.html
```

> üü¢ Swagger gera automaticamente a documenta√ß√£o e testes de endpoints.

---

## ‚úÖ **Resumo da Estrutura Final**

```
src/
 ‚îî‚îÄ‚îÄ main/
     ‚îú‚îÄ‚îÄ kotlin/
     ‚îÇ   ‚îî‚îÄ‚îÄ com/kotlin/crudexample/
     ‚îÇ       ‚îú‚îÄ‚îÄ controller/
     ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ProductController.kt
     ‚îÇ       ‚îú‚îÄ‚îÄ model/
     ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ Product.kt
     ‚îÇ       ‚îú‚îÄ‚îÄ repository/
     ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ProductRepository.kt
     ‚îÇ       ‚îî‚îÄ‚îÄ service/
     ‚îÇ           ‚îú‚îÄ‚îÄ ProductService.kt
     ‚îÇ           ‚îî‚îÄ‚îÄ ProductServiceImpl.kt
     ‚îî‚îÄ‚îÄ resources/
         ‚îî‚îÄ‚îÄ application.yml
```
---

## 17 ‚Äî Adicionar depend√™ncia no `build.gradle.kts`

Verifique se **essas linhas est√£o presentes** nas suas depend√™ncias:

```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
}
```

---

## 18 ‚Äî Criar o pacote de configura√ß√£o

Crie o arquivo no caminho:

```
src/main/kotlin/com/example/crudexample/config/SwaggerConfiguration.kt
```

E coloque exatamente o c√≥digo que voc√™ j√° colou:

```kotlin
package com.example.crudexample.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Contact
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.info.License
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfiguration {

    @Bean
    fun customOpenAPI(): OpenAPI {
        return OpenAPI()
            .info(
                Info()
                    .title("Api Title")
                    .description("Api Definition")
                    .version("1.0.0")
                    .contact(
                        Contact().apply {
                            name = "Rafael Moura"
                            url = "https://rafaelmoura.dev"
                            email = "teste@gmail.com"
                        }
                    )
                    .license(
                        License().apply {
                            name = "Apache 2.0"
                            url = "http://www.apache.org/licenses/LICENSE-2.0"
                        }
                    )
            )
    }
}
```

---

## 19 ‚Äî (Opcional) Configurar o `application.yml`

Se quiser personalizar o caminho da documenta√ß√£o (n√£o √© obrigat√≥rio):

```yaml
springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
```

---

## 20 ‚Äî Documentar os endpoints

Agora voc√™ pode usar as **anota√ß√µes OpenAPI 3** (`io.swagger.v3.oas.annotations.*`) nos seus controllers.

Exemplo:

```kotlin
package com.example.crudexample.controller

import com.example.crudexample.model.Product
import com.example.crudexample.service.ProductService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.web.bind.annotation.*

@Tag(name = "Product Controller", description = "Opera√ß√µes com produtos")
@RestController
@RequestMapping("/api")
class ProductController(private val productService: ProductService) {

    @Operation(summary = "Listar todos os produtos")
    @GetMapping("/products")
    fun getAll(): List<Product> = productService.getAll()

    @Operation(summary = "Buscar produto por ID")
    @GetMapping("/product/{id}")
    fun getById(@PathVariable id: Long): Product = productService.getById(id)

    @Operation(summary = "Criar um novo produto")
    @PostMapping("/product")
    fun create(@RequestBody product: Product): Product = productService.create(product)

    @Operation(summary = "Atualizar um produto existente")
    @PutMapping("/product")
    fun update(@RequestBody product: Product): String = productService.update(product)

    @Operation(summary = "Deletar um produto")
    @DeleteMapping("/product/{id}")
    fun delete(@PathVariable id: Long): String = productService.delete(id)
}
```

---

## 21 ‚Äî Rodar a aplica√ß√£o

Execute:

```bash
./gradlew bootRun
```

---

## 22 ‚Äî Acessar a documenta√ß√£o Swagger

Abra o navegador e v√° para:

```
http://localhost:8080/swagger-ui.html
```

ou (dependendo da vers√£o do Spring Boot):

```
http://localhost:8080/swagger-ui/index.html
```

Voc√™ ver√° a interface interativa do Swagger (com todos os endpoints que o Spring detectou).

---

## 23 ‚Äî Endpoints autom√°ticos do OpenAPI

O `springdoc` cria dois endpoints autom√°ticos:

* **JSON do OpenAPI:** `http://localhost:8080/v3/api-docs`
* **Swagger UI:** `http://localhost:8080/swagger-ui.html`

Esses endpoints permitem integra√ß√£o com ferramentas como Postman ou Insomnia.

---

Perfeito üëç
Vamos montar **um exemplo completo** de como criar uma tabela `products` com 5 campos e **modificar o `JpaRepository` para usar SQL nativo (via `@Query`)** no Spring Boot com Kotlin.

---

## 24 Criar a tabela `products`

Se voc√™ estiver usando um banco como MySQL ou Oracle, execute o SQL abaixo:

```sql
CREATE TABLE products (
    id INT auto_increment PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description VARCHAR(255),
    price DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```


## 25 Aletere a entidade `Product.kt`

```kotlin
package com.example.crudexample.model

import jakarta.persistence.*
import java.math.BigDecimal
import java.time.LocalDateTime

@Entity
@Table(name = "products")
data class Product(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(nullable = false)
    val name: String,

    val description: String? = null,

    @Column(nullable = false)
    val price: BigDecimal,

    @Column(nullable = false)
    val quantity: Int,

    @Column(name = "created_at")
    val createdAt: LocalDateTime = LocalDateTime.now()
)

```

---

## 26 Altere o `Repository` com consultas SQL nativas

```kotlin
package com.example.crudexample.repository

import com.example.crudexample.model.Product
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import org.springframework.data.jpa.repository.Modifying
import org.springframework.transaction.annotation.Transactional


@Repository
interface ProductRepository : JpaRepository<Product, Long> {

    // Busca todos os produtos (SQL nativo)
    @Query(value = "SELECT * FROM products", nativeQuery = true)
    fun findAllProducts(): List<Product>

    // Busca um produto pelo nome
    @Query(value = "SELECT * FROM products WHERE name = :name", nativeQuery = true)
    fun findByName(@Param("name") name: String): Product?

    // Busca produtos com pre√ßo acima de um valor
    @Query(value = "SELECT * FROM products WHERE price > :price", nativeQuery = true)
    fun findProductsAbovePrice(@Param("price") price: Double): List<Product>

    // Atualiza a quantidade de um produto
    @Modifying
    @Transactional
    @Query(value = "UPDATE products SET quantity = :quantity WHERE id = :id", nativeQuery = true)
    fun updateQuantity(@Param("id") id: Long, @Param("quantity") quantity: Int)

    // Deleta produto pelo nome
    @Modifying
    @Transactional
    @Query(value = "DELETE FROM products WHERE name = :name", nativeQuery = true)
    fun deleteByName(@Param("name") name: String)

}

```

üü° **Observa√ß√µes:**

* As queries usam `nativeQuery = true`, ou seja, s√£o **SQLs diretas no banco** (n√£o JPQL).
* Para o m√©todo `updateQuantity` e `deleteByName`, √© recomendado anotar o m√©todo com `@Modifying` e `@Transactional`:


## 26 Altere o `Service` com consultas SQL nativas
```kotlin
@Service
interface ProductService {
    fun getAll(): List<Product>
    fun getByName(name: String): Product?
    fun save(product: Product): Product
    fun update(product: Product): String
    fun updateQuantity( id: Long, quantity: Int)
    fun delete(name: String): String
}

```

```kotlin
package com.example.crudexample.service

import com.example.crudexample.model.Product
import com.example.crudexample.repository.ProductRepository
import org.springframework.stereotype.Service

@Service
class ProductServiceImpl(val productRepository: ProductRepository) : ProductService {

    override fun getAll(): List<Product> = productRepository.findAll()

    override fun getByName(name: String): Product? = productRepository.findByName(name)

    override fun save(product: Product): Product = productRepository.save(product)

    override fun update(product: Product): String {
        if (!productRepository.existsById(product.id))
            return "Produto n√£o existe na base de dados"

        productRepository.save(product)

        return "Produto id ${product.id} alterado com sucesso"
    }

    override fun updateQuantity(id: Long, quantity: Int) = productRepository.updateQuantity(id, quantity)

    override fun delete(name: String): String {
        /*if (!productRepository.existsById(id))
            return "Produto n√£o existe na base de dados"
*/
        productRepository.deleteByName(name)

        return "Produto removido com sucesso!"
    }
}

```
---

## 27 Altere o `Controller` para testar as chamadas

```kotlin
package com.example.crudexample.controller

import com.example.crudexample.model.Product
import com.example.crudexample.repository.ProductRepository
import com.example.crudexample.service.ProductService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/products")
class ProductController(
    private val productService: ProductService
) {

    @GetMapping
    fun getAll(): List<Product> = productService.getAll()

    @GetMapping("/{name}")
    fun getByName(@PathVariable name: String): Product? = productService.getByName(name)

    @PostMapping
    fun create(@RequestBody product: Product): Product = productService.save(product)

    @PutMapping("/{id}/quantity/{quantity}")
    fun updateQuantity(
        @PathVariable id: Long,
        @PathVariable quantity: Int
    ): String {
        productService.updateQuantity(id, quantity)
        return "Quantidade atualizada!"
    }

    @DeleteMapping("/{name}")
    fun deleteByName(@PathVariable name: String): String {
        productService.delete(name)
        return "Produto removido!"
    }
}

```

---

## 28 Testar no Swagger


üëâ **[http://localhost:8081/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)**

L√° voc√™ ver√°:

* **GET /products** ‚Üí lista todos
* **GET /products/{name}** ‚Üí busca por nome
* **POST /products** ‚Üí cria novo
* **PUT /products/{id}/quantity/{quantity}** ‚Üí atualiza quantidade
* **DELETE /products/{name}** ‚Üí remove

---



Refer√™ncia:
https://rafaelmoura.dev/kotlin-rest-api-completa-01
https://rafaelmoura.dev/kotlin-rest-api-completa-02
https://rafaelmoura.dev/kotlin-rest-api-completa-03
---

