

---

# **PROCESSADORES E ARQUITETURAS DE COMPUTADORES**

As arquiteturas de computadores definem **como um processador interpreta, executa e gerencia instruções**, determinando a eficiência de execução de programas e o consumo de energia do sistema. O estudo das arquiteturas não apenas permite **compreender o funcionamento do hardware**, mas também auxilia **desenvolvedores e engenheiros a otimizar software** e a projetar chips adaptados a diferentes aplicações.

Historicamente, a evolução das arquiteturas esteve ligada a fatores como velocidade do clock, capacidade de memória, custo de produção e necessidades de software. Dois tipos de arquitetura se destacam no estudo da computação: **CISC (Complex Instruction Set Computer)** e **RISC (Reduced Instruction Set Computer)**.

---

## **1. Arquitetura CISC**

CISC foi desenvolvida para **executar tarefas complexas com o menor número de instruções possíveis**, priorizando a facilidade do programador e a compatibilidade com linguagens de alto nível.

### **Histórico**

* Surgiu na década de 1970, período de limitação de memória e velocidade de clock.
* A ideia central era que **uma única instrução pudesse executar várias operações**, como cálculos, leitura/escrita de memória e controle de fluxo.
* Tornou-se dominante em PCs e servidores, com exemplos clássicos como **Intel 8086, 386, 486, Motorola 68000 e x86-64**.

### **Funcionamento**

* Cada instrução é traduzida em **microinstruções internas**.
* Essas microinstruções operam diretamente sobre **registradores, memória e ULA**, permitindo a execução de tarefas complexas de forma automática.
* Ideal para programas que exigem poucas linhas de código em Assembly ou linguagem de máquina.

### **Características**

* Controle **microprogramado**;
* Modos **registrador-registrador**, **registrador-memória** e **memória-registrador**;
* Múltiplos modos de **endereçamento**, incluindo indexação e vetores;
* **Instruções de tamanho variável**;
* **Execução em múltiplos ciclos**;
* **Poucos registradores**, alguns especializados;
* Capacidade de executar operações complexas com **uma única instrução**.

### **Vantagens**

* Reduz o tamanho do programa em linguagem de máquina;
* Maior **versatilidade** e compatibilidade retroativa;
* Facilita a tradução de linguagens de alto nível para instruções de máquina.

### **Desvantagens**

* Hardware mais **complexo e caro**;
* Maior consumo de energia;
* Dificuldade em implementar pipelines eficientes devido à variação de tamanho e complexidade das instruções.

### **Exemplos de instruções CISC**

| Instrução       | Função                                             |
| --------------- | -------------------------------------------------- |
| MOV AX, [BX+SI] | Carrega o conteúdo de um endereço de memória em AX |
| ADD AX, [BX+SI] | Soma o valor de um endereço de memória a AX        |
| MUL BX          | Multiplica AX por BX e armazena em DX:AX           |
| LOOP label      | Decrementa CX e pula para label se CX ≠ 0          |
| PUSH AX         | Empilha o conteúdo de AX na pilha                  |
| POP BX          | Desempilha o topo da pilha para BX                 |

---

## **2. Arquitetura RISC**

RISC surgiu na década de 1980 como **resposta às limitações do CISC**, simplificando o conjunto de instruções e priorizando **execução rápida e eficiente**.

### **Histórico**

* Com o aumento de memória e clock, tornou-se mais vantajoso usar **instruções simples e rápidas**, permitindo **pipeline e execução paralela**.
* Arquiteturas RISC tornaram-se populares em **dispositivos móveis, sistemas embarcados e processadores de baixo consumo**, como ARM, RISC-V, MIPS e PowerPC.

### **Funcionamento**

* Cada instrução é **simples e executada em um ciclo de clock**, sem microprogramação.
* Instruções de memória são separadas (**load/store**), isolando operações de cálculo e movimentação de dados.
* Uso intensivo de **registradores**, diminuindo acessos à memória e permitindo maior paralelismo.

### **Características**

* Execução de **uma instrução por ciclo**;
* **Formato de instrução fixo**, simplificando decodificação;
* **Conjunto reduzido de instruções**;
* Sem microcódigo, complexidade transferida ao compilador;
* Suporte a **pipeline e execução paralela**;
* Registradores abundantes para otimizar cálculos e movimentação de dados.

### **Vantagens**

* Processadores mais **simples, baratos e rápidos**;
* **Menor consumo de energia**, ideal para dispositivos móveis;
* Facilita técnicas modernas de otimização, como **execução fora de ordem** e **previsão de salto**;
* Permite clocks mais altos e pipelines eficientes.

### **Desvantagens**

* Operações complexas podem exigir várias instruções;
* Código Assembly tende a ser maior;
* Dependência de compiladores otimizados.

### **Exemplos de instruções RISC**

| Instrução         | Função                                   |
| ----------------- | ---------------------------------------- |
| ADD R1, R2, R3    | Soma R2 + R3 e armazena em R1            |
| SUB R4, R1, R2    | Subtrai R2 de R1 e armazena em R4        |
| LOAD R1, 0(R2)    | Carrega da memória para o registrador R1 |
| STORE R1, 0(R2)   | Armazena o conteúdo de R1 na memória     |
| BEQ R1, R2, label | Salta para label se R1 = R2              |
| NOP               | Nenhuma operação (espera ou alinhamento) |

---

## **3. Exemplo Prático: Soma de Dois Números**

**Tarefa:** Somar `A` e `B` e armazenar em `C`.

### **CISC**

```asm
ADD C, A, B
```

* Executa leitura, soma e escrita em **uma única instrução**.
* Internamente, pode envolver **várias microinstruções**.

### **RISC**

```asm
LOAD R1, A
LOAD R2, B
ADD R3, R1, R2
STORE R3, C
```

* Cada operação é simples e executada em **um ciclo de clock**.
* Pipeline facilita execução paralela e aumento de performance.

### **Comparativo**

| Etapa                  | CISC                    | RISC                           |
| ---------------------- | ----------------------- | ------------------------------ |
| Ler valores da memória | Incluso                 | LOAD R1, A; LOAD R2, B         |
| Soma                   | Incluso                 | ADD R3, R1, R2                 |
| Escrever resultado     | Incluso                 | STORE R3, C                    |
| Número de instruções   | 1                       | 4                              |
| Complexidade           | Alta (microprogramação) | Baixa (uma operação por ciclo) |

---

## **4. Comparação Geral RISC x CISC**

| Característica              | RISC                             | CISC                             |
| --------------------------- | -------------------------------- | -------------------------------- |
| Número de instruções        | Reduzido                         | Elevado                          |
| Complexidade das instruções | Simples                          | Complexas                        |
| Microcódigo                 | Não possui                       | Possui                           |
| Ciclos por instrução        | 1                                | Vários                           |
| Pipeline                    | Facilita                         | Mais difícil                     |
| Consumo de energia          | Baixo                            | Alto                             |
| Uso comum                   | Dispositivos móveis e embarcados | Desktops, notebooks e servidores |

> Observação: Arquiteturas modernas de ambos os tipos evoluíram: CISC usa microcódigo otimizado e RISC incorporou extensões para operações complexas. Ex.: **Apple Silicon (RISC/ARM)** supera CPUs CISC tradicionais em muitas tarefas.

---

## **5. Outras arquiteturas menos comuns**

* **VLIW (Very Long Instruction Word):** múltiplas operações em uma instrução longa, executadas em paralelo.
* **MISC (Minimal Instruction Set Computer):** conjunto mínimo de instruções, hardware simplificado.
* **OISC (One Instruction Set Computer):** apenas uma instrução, usado para ensino.
* **ZISC (Zero Instruction Set Computer):** baseado em reconhecimento de padrões, inspirado em redes neurais.

---

#  **Exercício 1 – Multiplicação e armazenamento do resultado**

### **Tarefa:**

Multiplicar dois valores armazenados na memória (`A` e `B`) e guardar o resultado em `C`.

---

## ** Arquitetura CISC**

Em um processador CISC (como o Intel x86), há instruções complexas que executam toda a operação em um único comando.

```asm
MUL C, A, B
```

### **Etapas internas (microprogramação CISC):**

1. **Buscar instrução:** `MUL C, A, B`
2. **Decodificar:** identificar os operandos e o tipo da operação.
3. **Microinstruções executadas:**

   * Ler `A` da memória para o registrador interno.
   * Ler `B` da memória para outro registrador interno.
   * Executar multiplicação na ULA.
   * Armazenar o resultado em `C`.
4. **Atualizar flags** (zero, overflow, sinal etc.).
5. **Avançar para a próxima instrução.**

> Resultado: todas essas etapas são encapsuladas em **uma única instrução complexa**.

---

## ** Arquitetura RISC**

Em RISC (como ARM ou MIPS), cada instrução realiza **apenas uma operação por vez**.

```asm
LOAD R1, A       ; Carrega A da memória
LOAD R2, B       ; Carrega B da memória
MUL R3, R1, R2   ; Multiplica R1 e R2
STORE R3, C      ; Armazena o resultado em C
```

### **Etapas da execução RISC:**

1. `LOAD` → transferência simples da memória para o registrador.
2. `MUL` → multiplicação feita diretamente na ULA.
3. `STORE` → gravação de volta na memória.

> Apesar de precisar de **4 instruções**, o pipeline RISC pode executá-las em **4 ciclos de clock paralelizados**, o que mantém o desempenho alto e o hardware simples.

---

## **Comparativo**

| Etapa                  | CISC                         | RISC                        |
| ---------------------- | ---------------------------- | --------------------------- |
| Número de instruções   | 1                            | 4                           |
| Tipo de instrução      | Complexa                     | Simples                     |
| Ciclos por instrução   | Vários (microprogramados)    | 1 por instrução             |
| Acesso à memória       | Integrado na instrução `MUL` | Apenas via `LOAD` e `STORE` |
| Facilidade de pipeline | Difícil                      | Alta                        |

---

# **Exercício 2 – Comparação e desvio condicional**

### **Tarefa:**

Comparar dois números (`X` e `Y`) e, caso sejam iguais, armazenar `1` em `FLAG`; caso contrário, armazenar `0`.

---

## ** Arquitetura CISC**

Em CISC, uma única instrução pode realizar **comparação e salto condicional**.

```asm
CMP X, Y          ; Compara X e Y
JE  IGUAL         ; Pula para o rótulo IGUAL se forem iguais
MOV FLAG, 0       ; Se não forem iguais, FLAG = 0
JMP FIM
IGUAL: MOV FLAG, 1
FIM:
```

### **Etapas (microprogramação CISC):**

1. `CMP` → lê X e Y, subtrai internamente e atualiza **flags**.
2. `JE` → verifica a flag “Zero”; se for 1, desvia para o endereço indicado.
3. `MOV` → escreve valor diretamente na memória ou registrador.
4. Cada uma dessas instruções pode envolver **várias microinstruções internas**, como leitura, comparação, salto e escrita.

> 🧩 O controle de fluxo e a comparação são implementados via **microprogramas complexos**.

---

## ** Arquitetura RISC**

Em RISC, o mesmo resultado é obtido com mais instruções simples:

```asm
LOAD R1, X
LOAD R2, Y
SUB R3, R1, R2
BEQ R3, R0, IGUAL     ; Se R3 = 0, desvia para IGUAL
ADDI R4, R0, 0        ; FLAG = 0
STORE R4, FLAG
J FIM
IGUAL: ADDI R4, R0, 1  ; FLAG = 1
STORE R4, FLAG
FIM:
```

### **Etapas RISC:**

1. As instruções são **simples e diretas** (sem microprogramação).
2. `BEQ` (Branch if Equal) usa o resultado da subtração para decidir o salto.
3. `ADDI` e `STORE` manipulam o valor da flag manualmente.
4. Cada linha é executada em **um ciclo de clock**, com **pipeline ativo**.

---

## **Comparativo**

| Característica            | CISC                                        | RISC                                      |
| ------------------------- | ------------------------------------------- | ----------------------------------------- |
| Instruções de controle    | Complexas, com salto e comparação embutidos | Simples, com comparação e salto separados |
| Número de instruções      | 4–5                                         | 7–8                                       |
| Execução média            | Mais lenta (múltiplos ciclos por instrução) | Mais rápida (1 ciclo por instrução)       |
| Implementação do controle | Microprogramada                             | Hardware direto                           |
| Eficiência em pipeline    | Baixa                                       | Alta                                      |

---

# 📘 **Conclusão Geral**

| Aspecto                    | CISC                                  | RISC                          |
| -------------------------- | ------------------------------------- | ----------------------------- |
| Filosofia de design        | Menos instruções, mais complexas      | Mais instruções, mais simples |
| Uso de microprogramação    | Extensivo                             | Pouco ou inexistente          |
| Tamanho do código Assembly | Menor                                 | Maior                         |
| Tempo de execução médio    | Maior (mais ciclos por instrução)     | Menor (1 ciclo por instrução) |
| Eficiência em pipeline     | Baixa                                 | Elevada                       |
| Exemplos de CPU            | Intel x86, AMD64, VAX, Motorola 68000 | ARM, RISC-V, MIPS, PowerPC    |

---

