

---

# **PROCESSADORES E ARQUITETURAS DE COMPUTADORES**

As arquiteturas de computadores definem **como um processador interpreta, executa e gerencia instru√ß√µes**, determinando a efici√™ncia de execu√ß√£o de programas e o consumo de energia do sistema. O estudo das arquiteturas n√£o apenas permite **compreender o funcionamento do hardware**, mas tamb√©m auxilia **desenvolvedores e engenheiros a otimizar software** e a projetar chips adaptados a diferentes aplica√ß√µes.

Historicamente, a evolu√ß√£o das arquiteturas esteve ligada a fatores como velocidade do clock, capacidade de mem√≥ria, custo de produ√ß√£o e necessidades de software. Dois tipos de arquitetura se destacam no estudo da computa√ß√£o: **CISC (Complex Instruction Set Computer)** e **RISC (Reduced Instruction Set Computer)**.

---

## **1. Arquitetura CISC**

CISC foi desenvolvida para **executar tarefas complexas com o menor n√∫mero de instru√ß√µes poss√≠veis**, priorizando a facilidade do programador e a compatibilidade com linguagens de alto n√≠vel.

### **Hist√≥rico**

* Surgiu na d√©cada de 1970, per√≠odo de limita√ß√£o de mem√≥ria e velocidade de clock.
* A ideia central era que **uma √∫nica instru√ß√£o pudesse executar v√°rias opera√ß√µes**, como c√°lculos, leitura/escrita de mem√≥ria e controle de fluxo.
* Tornou-se dominante em PCs e servidores, com exemplos cl√°ssicos como **Intel 8086, 386, 486, Motorola 68000 e x86-64**.

### **Funcionamento**

* Cada instru√ß√£o √© traduzida em **microinstru√ß√µes internas**.
* Essas microinstru√ß√µes operam diretamente sobre **registradores, mem√≥ria e ULA**, permitindo a execu√ß√£o de tarefas complexas de forma autom√°tica.
* Ideal para programas que exigem poucas linhas de c√≥digo em Assembly ou linguagem de m√°quina.

### **Caracter√≠sticas**

* Controle **microprogramado**;
* Modos **registrador-registrador**, **registrador-mem√≥ria** e **mem√≥ria-registrador**;
* M√∫ltiplos modos de **endere√ßamento**, incluindo indexa√ß√£o e vetores;
* **Instru√ß√µes de tamanho vari√°vel**;
* **Execu√ß√£o em m√∫ltiplos ciclos**;
* **Poucos registradores**, alguns especializados;
* Capacidade de executar opera√ß√µes complexas com **uma √∫nica instru√ß√£o**.

### **Vantagens**

* Reduz o tamanho do programa em linguagem de m√°quina;
* Maior **versatilidade** e compatibilidade retroativa;
* Facilita a tradu√ß√£o de linguagens de alto n√≠vel para instru√ß√µes de m√°quina.

### **Desvantagens**

* Hardware mais **complexo e caro**;
* Maior consumo de energia;
* Dificuldade em implementar pipelines eficientes devido √† varia√ß√£o de tamanho e complexidade das instru√ß√µes.

### **Exemplos de instru√ß√µes CISC**

| Instru√ß√£o       | Fun√ß√£o                                             |
| --------------- | -------------------------------------------------- |
| MOV AX, [BX+SI] | Carrega o conte√∫do de um endere√ßo de mem√≥ria em AX |
| ADD AX, [BX+SI] | Soma o valor de um endere√ßo de mem√≥ria a AX        |
| MUL BX          | Multiplica AX por BX e armazena em DX:AX           |
| LOOP label      | Decrementa CX e pula para label se CX ‚â† 0          |
| PUSH AX         | Empilha o conte√∫do de AX na pilha                  |
| POP BX          | Desempilha o topo da pilha para BX                 |

---

## **2. Arquitetura RISC**

RISC surgiu na d√©cada de 1980 como **resposta √†s limita√ß√µes do CISC**, simplificando o conjunto de instru√ß√µes e priorizando **execu√ß√£o r√°pida e eficiente**.

### **Hist√≥rico**

* Com o aumento de mem√≥ria e clock, tornou-se mais vantajoso usar **instru√ß√µes simples e r√°pidas**, permitindo **pipeline e execu√ß√£o paralela**.
* Arquiteturas RISC tornaram-se populares em **dispositivos m√≥veis, sistemas embarcados e processadores de baixo consumo**, como ARM, RISC-V, MIPS e PowerPC.

### **Funcionamento**

* Cada instru√ß√£o √© **simples e executada em um ciclo de clock**, sem microprograma√ß√£o.
* Instru√ß√µes de mem√≥ria s√£o separadas (**load/store**), isolando opera√ß√µes de c√°lculo e movimenta√ß√£o de dados.
* Uso intensivo de **registradores**, diminuindo acessos √† mem√≥ria e permitindo maior paralelismo.

### **Caracter√≠sticas**

* Execu√ß√£o de **uma instru√ß√£o por ciclo**;
* **Formato de instru√ß√£o fixo**, simplificando decodifica√ß√£o;
* **Conjunto reduzido de instru√ß√µes**;
* Sem microc√≥digo, complexidade transferida ao compilador;
* Suporte a **pipeline e execu√ß√£o paralela**;
* Registradores abundantes para otimizar c√°lculos e movimenta√ß√£o de dados.

### **Vantagens**

* Processadores mais **simples, baratos e r√°pidos**;
* **Menor consumo de energia**, ideal para dispositivos m√≥veis;
* Facilita t√©cnicas modernas de otimiza√ß√£o, como **execu√ß√£o fora de ordem** e **previs√£o de salto**;
* Permite clocks mais altos e pipelines eficientes.

### **Desvantagens**

* Opera√ß√µes complexas podem exigir v√°rias instru√ß√µes;
* C√≥digo Assembly tende a ser maior;
* Depend√™ncia de compiladores otimizados.

### **Exemplos de instru√ß√µes RISC**

| Instru√ß√£o         | Fun√ß√£o                                   |
| ----------------- | ---------------------------------------- |
| ADD R1, R2, R3    | Soma R2 + R3 e armazena em R1            |
| SUB R4, R1, R2    | Subtrai R2 de R1 e armazena em R4        |
| LOAD R1, 0(R2)    | Carrega da mem√≥ria para o registrador R1 |
| STORE R1, 0(R2)   | Armazena o conte√∫do de R1 na mem√≥ria     |
| BEQ R1, R2, label | Salta para label se R1 = R2              |
| NOP               | Nenhuma opera√ß√£o (espera ou alinhamento) |

---

## **3. Exemplo Pr√°tico: Soma de Dois N√∫meros**

**Tarefa:** Somar `A` e `B` e armazenar em `C`.

### **CISC**

```asm
ADD C, A, B
```

* Executa leitura, soma e escrita em **uma √∫nica instru√ß√£o**.
* Internamente, pode envolver **v√°rias microinstru√ß√µes**.

### **RISC**

```asm
LOAD R1, A
LOAD R2, B
ADD R3, R1, R2
STORE R3, C
```

* Cada opera√ß√£o √© simples e executada em **um ciclo de clock**.
* Pipeline facilita execu√ß√£o paralela e aumento de performance.

### **Comparativo**

| Etapa                  | CISC                    | RISC                           |
| ---------------------- | ----------------------- | ------------------------------ |
| Ler valores da mem√≥ria | Incluso                 | LOAD R1, A; LOAD R2, B         |
| Soma                   | Incluso                 | ADD R3, R1, R2                 |
| Escrever resultado     | Incluso                 | STORE R3, C                    |
| N√∫mero de instru√ß√µes   | 1                       | 4                              |
| Complexidade           | Alta (microprograma√ß√£o) | Baixa (uma opera√ß√£o por ciclo) |

---

## **4. Compara√ß√£o Geral RISC x CISC**

| Caracter√≠stica              | RISC                             | CISC                             |
| --------------------------- | -------------------------------- | -------------------------------- |
| N√∫mero de instru√ß√µes        | Reduzido                         | Elevado                          |
| Complexidade das instru√ß√µes | Simples                          | Complexas                        |
| Microc√≥digo                 | N√£o possui                       | Possui                           |
| Ciclos por instru√ß√£o        | 1                                | V√°rios                           |
| Pipeline                    | Facilita                         | Mais dif√≠cil                     |
| Consumo de energia          | Baixo                            | Alto                             |
| Uso comum                   | Dispositivos m√≥veis e embarcados | Desktops, notebooks e servidores |

> Observa√ß√£o: Arquiteturas modernas de ambos os tipos evolu√≠ram: CISC usa microc√≥digo otimizado e RISC incorporou extens√µes para opera√ß√µes complexas. Ex.: **Apple Silicon (RISC/ARM)** supera CPUs CISC tradicionais em muitas tarefas.

---

## **5. Outras arquiteturas menos comuns**

* **VLIW (Very Long Instruction Word):** m√∫ltiplas opera√ß√µes em uma instru√ß√£o longa, executadas em paralelo.
* **MISC (Minimal Instruction Set Computer):** conjunto m√≠nimo de instru√ß√µes, hardware simplificado.
* **OISC (One Instruction Set Computer):** apenas uma instru√ß√£o, usado para ensino.
* **ZISC (Zero Instruction Set Computer):** baseado em reconhecimento de padr√µes, inspirado em redes neurais.

---

#  **Exerc√≠cio 1 ‚Äì Multiplica√ß√£o e armazenamento do resultado**

### **Tarefa:**

Multiplicar dois valores armazenados na mem√≥ria (`A` e `B`) e guardar o resultado em `C`.

---

## ** Arquitetura CISC**

Em um processador CISC (como o Intel x86), h√° instru√ß√µes complexas que executam toda a opera√ß√£o em um √∫nico comando.

```asm
MUL C, A, B
```

### **Etapas internas (microprograma√ß√£o CISC):**

1. **Buscar instru√ß√£o:** `MUL C, A, B`
2. **Decodificar:** identificar os operandos e o tipo da opera√ß√£o.
3. **Microinstru√ß√µes executadas:**

   * Ler `A` da mem√≥ria para o registrador interno.
   * Ler `B` da mem√≥ria para outro registrador interno.
   * Executar multiplica√ß√£o na ULA.
   * Armazenar o resultado em `C`.
4. **Atualizar flags** (zero, overflow, sinal etc.).
5. **Avan√ßar para a pr√≥xima instru√ß√£o.**

> Resultado: todas essas etapas s√£o encapsuladas em **uma √∫nica instru√ß√£o complexa**.

---

## ** Arquitetura RISC**

Em RISC (como ARM ou MIPS), cada instru√ß√£o realiza **apenas uma opera√ß√£o por vez**.

```asm
LOAD R1, A       ; Carrega A da mem√≥ria
LOAD R2, B       ; Carrega B da mem√≥ria
MUL R3, R1, R2   ; Multiplica R1 e R2
STORE R3, C      ; Armazena o resultado em C
```

### **Etapas da execu√ß√£o RISC:**

1. `LOAD` ‚Üí transfer√™ncia simples da mem√≥ria para o registrador.
2. `MUL` ‚Üí multiplica√ß√£o feita diretamente na ULA.
3. `STORE` ‚Üí grava√ß√£o de volta na mem√≥ria.

> Apesar de precisar de **4 instru√ß√µes**, o pipeline RISC pode execut√°-las em **4 ciclos de clock paralelizados**, o que mant√©m o desempenho alto e o hardware simples.

---

## **Comparativo**

| Etapa                  | CISC                         | RISC                        |
| ---------------------- | ---------------------------- | --------------------------- |
| N√∫mero de instru√ß√µes   | 1                            | 4                           |
| Tipo de instru√ß√£o      | Complexa                     | Simples                     |
| Ciclos por instru√ß√£o   | V√°rios (microprogramados)    | 1 por instru√ß√£o             |
| Acesso √† mem√≥ria       | Integrado na instru√ß√£o `MUL` | Apenas via `LOAD` e `STORE` |
| Facilidade de pipeline | Dif√≠cil                      | Alta                        |

---

# **Exerc√≠cio 2 ‚Äì Compara√ß√£o e desvio condicional**

### **Tarefa:**

Comparar dois n√∫meros (`X` e `Y`) e, caso sejam iguais, armazenar `1` em `FLAG`; caso contr√°rio, armazenar `0`.

---

## ** Arquitetura CISC**

Em CISC, uma √∫nica instru√ß√£o pode realizar **compara√ß√£o e salto condicional**.

```asm
CMP X, Y          ; Compara X e Y
JE  IGUAL         ; Pula para o r√≥tulo IGUAL se forem iguais
MOV FLAG, 0       ; Se n√£o forem iguais, FLAG = 0
JMP FIM
IGUAL: MOV FLAG, 1
FIM:
```

### **Etapas (microprograma√ß√£o CISC):**

1. `CMP` ‚Üí l√™ X e Y, subtrai internamente e atualiza **flags**.
2. `JE` ‚Üí verifica a flag ‚ÄúZero‚Äù; se for 1, desvia para o endere√ßo indicado.
3. `MOV` ‚Üí escreve valor diretamente na mem√≥ria ou registrador.
4. Cada uma dessas instru√ß√µes pode envolver **v√°rias microinstru√ß√µes internas**, como leitura, compara√ß√£o, salto e escrita.

> üß© O controle de fluxo e a compara√ß√£o s√£o implementados via **microprogramas complexos**.

---

## ** Arquitetura RISC**

Em RISC, o mesmo resultado √© obtido com mais instru√ß√µes simples:

```asm
LOAD R1, X
LOAD R2, Y
SUB R3, R1, R2
BEQ R3, R0, IGUAL     ; Se R3 = 0, desvia para IGUAL
ADDI R4, R0, 0        ; FLAG = 0
STORE R4, FLAG
J FIM
IGUAL: ADDI R4, R0, 1  ; FLAG = 1
STORE R4, FLAG
FIM:
```

### **Etapas RISC:**

1. As instru√ß√µes s√£o **simples e diretas** (sem microprograma√ß√£o).
2. `BEQ` (Branch if Equal) usa o resultado da subtra√ß√£o para decidir o salto.
3. `ADDI` e `STORE` manipulam o valor da flag manualmente.
4. Cada linha √© executada em **um ciclo de clock**, com **pipeline ativo**.

---

## **Comparativo**

| Caracter√≠stica            | CISC                                        | RISC                                      |
| ------------------------- | ------------------------------------------- | ----------------------------------------- |
| Instru√ß√µes de controle    | Complexas, com salto e compara√ß√£o embutidos | Simples, com compara√ß√£o e salto separados |
| N√∫mero de instru√ß√µes      | 4‚Äì5                                         | 7‚Äì8                                       |
| Execu√ß√£o m√©dia            | Mais lenta (m√∫ltiplos ciclos por instru√ß√£o) | Mais r√°pida (1 ciclo por instru√ß√£o)       |
| Implementa√ß√£o do controle | Microprogramada                             | Hardware direto                           |
| Efici√™ncia em pipeline    | Baixa                                       | Alta                                      |

---

# üìò **Conclus√£o Geral**

| Aspecto                    | CISC                                  | RISC                          |
| -------------------------- | ------------------------------------- | ----------------------------- |
| Filosofia de design        | Menos instru√ß√µes, mais complexas      | Mais instru√ß√µes, mais simples |
| Uso de microprograma√ß√£o    | Extensivo                             | Pouco ou inexistente          |
| Tamanho do c√≥digo Assembly | Menor                                 | Maior                         |
| Tempo de execu√ß√£o m√©dio    | Maior (mais ciclos por instru√ß√£o)     | Menor (1 ciclo por instru√ß√£o) |
| Efici√™ncia em pipeline     | Baixa                                 | Elevada                       |
| Exemplos de CPU            | Intel x86, AMD64, VAX, Motorola 68000 | ARM, RISC-V, MIPS, PowerPC    |

---

