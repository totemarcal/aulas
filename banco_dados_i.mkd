## Sistemas de Banco de Dados

### Dado, Informa√ß√£o e Conhecimento

- **Dado**: √© o componente b√°sico de um arquivo, √© um elemento com um significado no mundo real, que comp√µe um sistema de arquivos. Como exemplo, podemos citar nome, sobrenome, cidade, bairro e outros.
- **Informa√ß√£o**: ap√≥s a interpreta√ß√£o dos dados, √© poss√≠vel associar um significado aos dados ou process√°-los. Normalmente, a informa√ß√£o vem de conven√ß√µes utilizadas por pessoas por meio de associa√ß√µes aos dados.
- **Conhecimento**: todo discernimento, obtido por meio de crit√©rios, e aprecia√ß√£o aos dados e informa√ß√µes.

#### Exemplo

O registro √© composto por seis itens de dados (campos): c√≥digo, CPF, nome, rua, bairro, cidade. Dentro do Banco de Dados, as fichas de todos os clientes que est√£o inseridas formar√£o o arquivo cliente.

Tomando como exemplo uma pesquisa eleitoral: cada entrevistado fornece opini√µes conforme as suas prefer√™ncias entre os candidatos, mas essa opini√£o individual n√£o significa muita coisa no contexto da elei√ß√£o. A opini√£o de um entrevistado √∫nico √© um dado. Por√©m, depois de ser integrada √†s opini√µes dos demais respondentes, torna-se algo com significado, uma informa√ß√£o.

Agora, tomando como exemplo um n√∫mero de telefone: `(11) 58899.3587` √© um n√∫mero, mas n√£o carrega significado por si s√≥; √© um dado. J√° na frase **"O n√∫mero do telefone da Viviane √© (11) 58899.3587"**, temos uma informa√ß√£o!

---

### Defini√ß√£o de Banco de Dados

- **Chu (1983)**: "Um Banco de Dados √© um conjunto de arquivos relacionados entre si".
- **C. J. Date (1985)**: "Um Banco de Dados √© uma cole√ß√£o de dados operacionais armazenados, sendo usados pelos sistemas de aplica√ß√£o de uma determinada organiza√ß√£o".
- **Elmasri e Navathe (2005)**: "Um Banco de Dados √© uma cole√ß√£o de dados relacionais".
- **Torey et al. (2007, p.2)**: "Um Banco de Dados √© um objeto mais complexo, √© uma cole√ß√£o de dados armazenados e inter-relacionados, que atende √†s necessidades de v√°rios usu√°rios dentro de uma ou mais organiza√ß√µes, ou seja, cole√ß√µes inter-relacionadas de muitos tipos diferentes de tabelas".

---

### Sistema de Gerenciamento de Banco de Dados

Segundo **DATE (2004)**, um **Sistema Gerenciador de Banco de Dados (SGBD)** √© um software gen√©rico para manipular Banco de Dados. Ele permite a defini√ß√£o, constru√ß√£o e manejo de um Banco de Dados para diversas aplica√ß√µes. Um SGBD possui:

- **Vis√£o l√≥gica**: projeto do BD.
- **Linguagem de defini√ß√£o de dados (DDL)**: usada para definir o esquema conceitual do Banco de Dados.
- **Linguagem de manipula√ß√£o de dados (DML)**: empregada para especificar as recupera√ß√µes e atualiza√ß√µes do Banco de Dados.
- **Utilit√°rios importantes**: auxiliam na administra√ß√£o e manuten√ß√£o do BD.

Os SGBDs tamb√©m facilitam a convers√£o e a reorganiza√ß√£o do Banco de Dados. Dessa forma, podemos dizer que os SGBDs s√£o programas de computador que ajudam na:

- **Defini√ß√£o e constru√ß√£o do Banco de Dados**: processo de criar uma estrutura inicial com tabelas e preench√™-las com dados.
- **Manipula√ß√£o dos dados do Banco de Dados**: opera√ß√µes de consultas, altera√ß√£o e exclus√£o realizadas nos dados.


### Fun√ß√µes b√°sicas dos SGBD est√£o listadas abaixo:

- M√©todos de acesso
- Restri√ß√µes de Integridade
- Seguran√ßa de dados
- Controle de Concorr√™ncia
- Indep√™ndicia de dados

---

### N√≠veis de Abstra√ß√£o

Uma das fun√ß√µes essenciais ao **DBA** √© utilizar **abstra√ß√£o de dados**. Com a utiliza√ß√£o da abstra√ß√£o de dados, √© poss√≠vel esconder certos ‚Äúdetalhes‚Äù sobre como os dados est√£o armazenados e como √© realizada a manuten√ß√£o, para facilitar o entendimento do usu√°rio (**JUKIC, VRBSKY S e NESTOROV, 2013**).

- **N√≠vel f√≠sico**: Descreve como os dados est√£o armazenados. Este √© o n√≠vel mais baixo de abstra√ß√£o.
- **N√≠vel l√≥gico**: Esse n√≠vel de abstra√ß√£o est√° acima do f√≠sico e descreve quais dados est√£o armazenados no BD e quais s√£o suas rela√ß√µes. Descreve o Banco de Dados inteiro em termos de um pequeno n√∫mero de estruturas relativamente simples.
- **N√≠vel de vis√µes (View)**: Esse n√≠vel pode ser visto pelo usu√°rio de diversas formas, pois quem opera s√£o os sistemas aplicativos. Esse n√≠vel existe para facilitar sua intera√ß√£o com o sistema, ou seja, o sistema pode fornecer muitas vis√µes para o mesmo Banco de Dados.

---

### Projeto de Banco de Dados

1. **Defini√ß√£o do sistema**: nesta etapa √© determinado o escopo do sistema, o que dever√° ser armazenado e quais ser√£o as opera√ß√µes realizadas, assim como seus usu√°rios.
2. **Projeto do Banco de Dados**: cria√ß√£o do projeto conceitual, l√≥gico e f√≠sico.
3. **Implementa√ß√£o do Banco de Dados**: cria√ß√£o real do Banco de Dados conforme os esquemas definidos na etapa anterior.
4. **Carga ou convers√£o de dados**: o Banco de Dados √© preenchido com dados j√° existentes ou preenchido manualmente.
5. **Convers√£o de aplica√ß√£o**: programas que antes acessavam o banco s√£o informados sobre as modifica√ß√µes do novo banco (etapa auxiliar).
6. **Teste e valida√ß√£o**: verifica-se se tudo est√° funcionando de acordo com o planejamento.
7. **Opera√ß√£o**: disponibiliza√ß√£o do sistema para uso.
8. **Monitoramento e manuten√ß√£o**: observa√ß√£o do funcionamento do sistema para poss√≠veis ajustes.

### Tipos de Banco de Dados

| **Tipo de SGBD**             | **Estrutura de Dados**                                      | **Caracter√≠sticas**                                                                 | **Exemplos**                        | **Linguagem de Consulta**          | **Exemplos de Linguagens de Consulta**   | **Quem Utiliza**                       |
|------------------------------|-------------------------------------------------------------|--------------------------------------------------------------------------------------|-------------------------------------|------------------------------------|-----------------------------------------|----------------------------------------|
| **SGBD Relacional (RDBMS)**  | Tabelas com linhas e colunas, onde os dados s√£o organizados em rela√ß√µes | - Usa SQL (Structured Query Language) para consultas. <br> - Suporta normaliza√ß√£o. <br> - Relacionamentos entre tabelas usando chaves prim√°rias e estrangeiras. | Oracle, MySQL, Microsoft SQL Server, PostgreSQL | SQL (Structured Query Language)    | **Exemplo**: `SELECT * FROM clientes WHERE idade > 30;` | Empresas de todos os tamanhos e setores (finan√ßas, sa√∫de, com√©rcio, etc.), que precisam de consist√™ncia e relacionamentos complexos entre dados. |
| **SGBD N√£o Relacional (NoSQL)** | Dados n√£o estruturados ou semi-estruturados (ex.: documentos, chave-valor) | - Suporta grandes volumes de dados distribu√≠dos. <br> - Flex√≠vel quanto ao formato dos dados. <br> - Escalabilidade horizontal. | MongoDB, Cassandra, Redis          | Depende do SGBD (ex.: MongoDB Query Language, CQL) | **MongoDB Query**: `db.clientes.find({idade: {$gt: 30}});` <br> **Cassandra Query Language (CQL)**: `SELECT * FROM clientes WHERE idade > 30;` | Empresas que lidam com Big Data, redes sociais, IoT, e-commerce e startups tecnol√≥gicas que exigem flexibilidade, escalabilidade e alto desempenho. |
| **SGBD Orientado a Objetos** | Objetos (semelhante a objetos em linguagens de programa√ß√£o) | - Armazena dados como objetos. <br> - Suporta heran√ßa, polimorfismo e encapsulamento. <br> - Ideal para aplica√ß√µes orientadas a objetos. | ObjectDB, db4o                     | OQL (Object Query Language)       | **Exemplo**: `SELECT FROM Cliente WHERE idade > 30;` | Desenvolvedores de software que utilizam programa√ß√£o orientada a objetos e precisam de um banco de dados que se integre facilmente a esse paradigma. |
| **SGBD Hier√°rquico**         | Estrutura de √°rvore (cada registro tem um √∫nico pai)        | - Dados s√£o organizados em um modelo de √°rvore. <br> - Relacionamentos s√£o fixos, com hierarquias predefinidas. | IBM IMS                            | Linguagem de consulta pr√≥pria (ex.: IMS Database Language) | **Exemplo**: `SELECT * FROM (EMPLOYEE) WHERE SUPERVISOR = 'John';` | Grandes corpora√ß√µes com sistemas legados que ainda utilizam estruturas hier√°rquicas para processamento de dados, como bancos e empresas de telecomunica√ß√µes. |
| **SGBD de Rede**             | Rede de registros interligados, permitindo m√∫ltiplos pais   | - Semelhante ao modelo hier√°rquico, mas com m√∫ltiplos pais. <br> - Mais flex√≠vel que o hier√°rquico, por√©m mais complexo. | IDMS                               | Linguagem de consulta pr√≥pria (ex.: Network Query Language) | **Exemplo**: `FIND EMPLOYEE WHERE EMPLOYEE_ID = '123';` | Empresas com sistemas legados, principalmente em setores como finan√ßas, onde a estrutura de dados precisa de relacionamentos complexos e flexibilidade. |

---

## Modelo Conceitual

O Modelo Relacional de Dados, definido por E. F. Codd em 1970 enquanto trabalhava na IBM, revolucionou a forma como os bancos de dados eram estruturados e manipulados. Sua proposta baseia-se na organiza√ß√£o dos dados em tabelas (ou rela√ß√µes), utilizando chaves prim√°rias e estrangeiras para estabelecer conex√µes entre os dados de forma estruturada e eficiente.

### 1. **Simplicidade** dos conceitos de base

- O modelo relacional utiliza um formato tabular simples, onde os dados s√£o organizados em linhas e colunas, facilitando a compreens√£o e a manipula√ß√£o.
- Cada tabela representa uma entidade, e cada linha (tupla) representa um registro √∫nico dessa entidade.


### 2. Rigor dos **conceitos** (tanto estruturas como operadores)

- Diferente de modelos anteriores, que eram mais flex√≠veis e menos estruturados, o modelo relacional define regras rigorosas para a manipula√ß√£o de dados.
- Conceitos como normaliza√ß√£o ajudam a evitar redund√¢ncia e anomalias nos dados.

### 3. Aspecto de Estrutura  

O banco de dados relacional √© representado por um conjunto de **rela√ß√µes (tabelas)**, onde:  
- Cada **rela√ß√£o** corresponde a uma **tabela**.  
- As **linhas (tuplas)** representam registros individuais da tabela.  
- As **colunas (atributos)** representam os diferentes campos ou propriedades armazenadas.  
- Uma **chave prim√°ria** √© usada para identificar unicamente cada tupla.  
- **Chaves estrangeiras** estabelecem rela√ß√µes entre tabelas.  

### 4. Aspecto de Integridade  
As rela√ß√µes devem satisfazer certas **restri√ß√µes de integridade** para garantir a consist√™ncia dos dados. Entre as principais restri√ß√µes, destacam-se:  
- **Integridade de entidade**: Cada tabela deve possuir uma **chave prim√°ria** √∫nica para evitar registros duplicados.  
- **Integridade referencial**: As **chaves estrangeiras** devem referenciar valores v√°lidos em outras tabelas, garantindo a coer√™ncia dos relacionamentos.  
- **Integridade de dom√≠nio**: Os valores inseridos em uma coluna devem obedecer ao **tipo de dado** definido (exemplo: n√∫meros em colunas num√©ricas).  

O **Modelo Relacional de Dados** serviu de base para o desenvolvimento dos **bancos de dados relacionais (RDBMS)**, como **MySQL, PostgreSQL, Oracle e SQL Server**, e influenciou a cria√ß√£o da linguagem **SQL (Structured Query Language)**, amplamente utilizada para consultas e manipula√ß√£o de dados.


## Terminologia Formal do Modelo Relacional de Dados

No **Modelo Relacional de Dados**, os elementos b√°sicos possuem nomes espec√≠ficos:

- **Tupla**: Uma linha da tabela (representa um registro).  
- **Atributo**: O t√≠tulo de uma coluna da tabela (representa uma propriedade dos dados).  
- **Rela√ß√£o**: A tabela em si (conjunto de tuplas e atributos).  
Onde:
 **R** √© o nome da rela√ß√£o (ou tabela).
 **A1, A2, ..., An** s√£o os atributos (colunas da tabela).
 Cada **atributo A** representa um papel desempenhado por algum **dom√≠nio D** dentro do esquema da rela√ß√£o R.

- **Dom√≠nio**: O tipo de dado que descreve os poss√≠veis valores que podem aparecer em uma coluna.
Onde:
**Ai** representa um atributo espec√≠fico.
**D(Ai)** ou **dom(Ai)** representa o dom√≠nio de valores at√¥micos (indivis√≠veis) permitidos para esse atributo.

**Papel do Dom√≠nio em uma Rela√ß√£o**
1. **Garante a validade dos dados**:  
   - Um atributo **"idade"** deve conter apenas n√∫meros inteiros positivos.  
   - Um atributo **"email"** deve seguir o formato de endere√ßos de e-mail.  

2. **Previne erros e inconsist√™ncias**:  
   - O dom√≠nio impede que valores inv√°lidos sejam inseridos no banco de dados.  

3. **Facilita a manipula√ß√£o de dados**:  
   - Ao definir um dom√≠nio corretamente, operadores e fun√ß√µes podem ser aplicados sem necessidade de valida√ß√£o adicional.  

**Exemplo Pr√°tico**
Vamos considerar uma rela√ß√£o **Aluno** com os seguintes atributos:

Os dom√≠nios dos atributos s√£o:

| **Atributo** | **Dom√≠nio (D(Ai))**                          | **Exemplo de Valor**     |
|-------------|----------------------------------|---------------------|
| **matricula** | N√∫meros inteiros positivos     | 1001, 1002, 1003    |
| **nome**      | Cadeia de caracteres (m√°x. 50) | "Jo√£o Silva"        |
| **idade**     | N√∫meros inteiros (0-120)       | 20, 35, 45          |
| **telefone**  | Formato de telefone v√°lido     | (11) 98765-4321     |

## **Atributos Devem Ser Diferentes**
Segundo a **teoria dos conjuntos**, os atributos de uma rela√ß√£o devem ser **diferentes entre si**. Ou seja, uma rela√ß√£o **n√£o pode conter dois atributos com o mesmo nome**.

**Por que os atributos devem ser √∫nicos?**
- Evita **ambiguidade** na manipula√ß√£o dos dados.
- Garante **univocidade** na representa√ß√£o da rela√ß√£o.
- Facilita **opera√ß√µes de jun√ß√£o e proje√ß√£o**.

### Exemplo Pr√°tico:

**Tabela: Customers (Clientes)**

| **CustomerID** | **Name**       | **Email**             | **City**          |
|--------------|---------------|----------------------|----------------|
| 1            | Jo√£o Silva    | joao@email.com      | S√£o Paulo     |
| 2            | Maria Souza   | maria@email.com     | Rio de Janeiro |
| 3            | Carlos Lima   | carlos@email.com    | Salvador      |
| 4            | Ana Pereira   | ana@email.com       | Belo Horizonte |
| 5            | Pedro Santos  | pedro@email.com     | Curitiba      |

- **Atributos**: CustomerID, Name, Email, City.  
- **Rela√ß√£o**: A tabela inteira "Customers".  
- **Tupla**: Cada linha da tabela. Exemplo: `(2, Maria Souza, maria@email.com, Rio de Janeiro)`.  
- **Dom√≠nio**:  
  - O atributo **CustomerID** tem um dom√≠nio de **valores inteiros positivos e √∫nicos**.  
  - O atributo **Name** tem um dom√≠nio de **cadeias de caracteres (texto) com nomes de clientes**.  
  - O atributo **Email** tem um dom√≠nio de **endere√ßos de e-mail v√°lidos**.  
  - O atributo **City** tem um dom√≠nio de **cidades existentes**.

# Formula√ß√£o Matem√°tica de uma Rela√ß√£o no Modelo Relacional

Seja uma **rela√ß√£o** \( R \) composta pelos atributos \( A1, A2, ..., An \), e os **dom√≠nios** \( dom(A1), dom(A2), ..., dom(An) \) dos respectivos atributos. A **rela√ß√£o** \( R \) √© um **subconjunto** do produto cartesiano dos dom√≠nios que definem os atributos da rela√ß√£o.

A formula√ß√£o matem√°tica √© a seguinte:

### **Defini√ß√£o Formal**

Seja:
- \( A1, A2, ..., An \) os atributos de uma rela√ß√£o \( R \).
- \( dom(A1), dom(A2), ..., dom(An) \) os dom√≠nios dos respectivos atributos.

Ent√£o, uma **rela√ß√£o** \( R \) pode ser representada matematicamente como:

\[
r(R) \subseteq (dom(A1) \times dom(A2) \times ... \times dom(An))
\]

Onde:
- \( r(R) \) √© o conjunto de tuplas que formam a rela√ß√£o \( R \).
- \( dom(Ai) \) √© o dom√≠nio do atributo \( Ai \), ou seja, o conjunto de valores poss√≠veis para \( Ai \).
- \( \times \) denota o **produto cartesiano** dos dom√≠nios, ou seja, o conjunto de todas as combina√ß√µes poss√≠veis dos valores dos dom√≠nios de \( A1, A2, ..., An \).

### **Explica√ß√£o do Produto Cartesiano**

O **produto cartesiano** dos dom√≠nios \( dom(A1), dom(A2), ..., dom(An) \) gera um conjunto de tuplas, onde cada tupla cont√©m uma combina√ß√£o dos valores poss√≠veis de cada dom√≠nio. Por exemplo:

- Se \( dom(A1) = \{1, 2\} \) e \( dom(A2) = \{x, y\} \), o produto cartesiano \( dom(A1) \times dom(A2) \) seria:

\[
dom(A1) \times dom(A2) = \{(1, x), (1, y), (2, x), (2, y)\}
\]

A rela√ß√£o \( r(R) \) ser√° um subconjunto deste produto cartesiano. Ou seja, a rela√ß√£o \( R \) pode conter algumas (ou todas) as combina√ß√µes poss√≠veis, dependendo dos dados inseridos na tabela.

### **Exemplo Pr√°tico**

Considerando a rela√ß√£o **Aluno**, com os seguintes atributos e dom√≠nios:

- \( Aluno(matricula, nome, idade) \)
- \( dom(matricula) = \{1001, 1002\} \)
- \( dom(nome) = \{Jo√£o, Maria\} \)
- \( dom(idade) = \{18, 19\} \)

O produto cartesiano seria:

\[
dom(matricula) \times dom(nome) \times dom(idade) = \{(1001, Jo√£o, 18), (1001, Jo√£o, 19), (1001, Maria, 18), (1001, Maria, 19), (1002, Jo√£o, 18), (1002, Jo√£o, 19), (1002, Maria, 18), (1002, Maria, 19)\}
\]

Agora, a rela√ß√£o \( r(Aluno) \) poderia ser um subconjunto desse conjunto, por exemplo:

\[
r(Aluno) = \{(1001, Jo√£o, 18), (1002, Maria, 19)\}
\]

Este subconjunto cont√©m apenas algumas das combina√ß√µes poss√≠veis.

---

### **Conclus√£o**
- Uma **rela√ß√£o** no modelo relacional √© um subconjunto do produto cartesiano dos dom√≠nios de seus atributos.
- A f√≥rmula \( r(R) \subseteq (dom(A1) \times dom(A2) \times ... \times dom(An)) \) descreve matematicamente essa estrutura.
- O **produto cartesiano** gera todas as combina√ß√µes poss√≠veis de valores, e a rela√ß√£o seleciona quais dessas combina√ß√µes s√£o armazenadas.

Esse entendimento √© fundamental para modelar dados em **bancos de dados relacionais** e compreender como as **rela√ß√µes** s√£o formadas e manipuladas.

# Conceitos de Tupla, Grau e Cardinalidade no Modelo Relacional

### **Tupla**
Uma **tupla** √© uma **lista ordenada de valores** que representam dados em uma rela√ß√£o. Cada valor na tupla corresponde a um **atributo** da rela√ß√£o e pertence ao dom√≠nio desse atributo ou pode ser um valor especial **nulo**.

#### **Nota√ß√£o**
Uma tupla \( t \) √© representada como:

\[
t = <v1, v2, ..., vn>
\]

Onde:
- \( v1, v2, ..., vn \) s√£o os valores da tupla, sendo que cada \( vi \) √© um valor pertencente ao **dom√≠nio** de um atributo \( Ai \) da rela√ß√£o.
- \( n \) √© o n√∫mero de atributos da rela√ß√£o (o **grau** da rela√ß√£o).
- Cada \( vi \) pode ser um valor at√¥mico ou um valor especial **nulo** (representando a aus√™ncia de valor).

#### **Exemplo de Tupla**
Considerando a rela√ß√£o **Aluno**, com os atributos:

- **matricula**
- **nome**
- **idade**

Uma tupla poderia ser:

\[
t = <1001, "Jo√£o Silva", 20>
\]

Onde:
- **1001** √© o valor da matr√≠cula.
- **"Jo√£o Silva"** √© o valor do nome.
- **20** √© o valor da idade.

Ou, se algum valor estiver ausente (como no caso de um telefone n√£o fornecido), pode ser representado como **nulo**:

\[
t = <1002, "Maria Souza", nulo>
\]

#### **Rela√ß√£o**
Uma **rela√ß√£o** \( r(R) \) √© um **conjunto de n-tuplas** que pertencem a uma rela√ß√£o \( R \).

A nota√ß√£o de uma rela√ß√£o seria:

\[
r(R) = \{t1, t2, ..., tm\}
\]

Onde:
- \( t1, t2, ..., tm \) s√£o as tuplas que fazem parte da rela√ß√£o \( R \).
- \( m \) √© a **cardinalidade** da rela√ß√£o, ou seja, o n√∫mero de tuplas.

---

## **Grau de uma Rela√ß√£o**
O **grau** de uma rela√ß√£o √© o **n√∫mero de atributos** presentes na rela√ß√£o. Em outras palavras, o grau de uma rela√ß√£o \( R \) √© o n√∫mero de **colunas** da tabela que a representa.

### **Exemplo de Grau**
Considerando a rela√ß√£o **Aluno**:

\[
Aluno(matricula, nome, idade)
\]

O grau da rela√ß√£o **Aluno** √© 3, porque ela possui 3 atributos.

---

## **Cardinalidade de uma Rela√ß√£o**
A **cardinalidade** de uma rela√ß√£o √© o **n√∫mero de tuplas** que ela cont√©m. A cardinalidade indica a **quantidade de registros** na tabela que representa a rela√ß√£o.

### **Exemplo de Cardinalidade**
Se a rela√ß√£o **Aluno** contiver as seguintes tuplas:

\[
r(Aluno) = \{(1001, "Jo√£o Silva", 20), (1002, "Maria Souza", 19), (1003, "Carlos Lima", 22)\}
\]

A cardinalidade da rela√ß√£o **Aluno** √© 3, porque existem 3 tuplas na rela√ß√£o.

---

## **Resumo dos Conceitos**
- **Tupla**: Lista ordenada de valores representando um registro na rela√ß√£o, onde cada valor corresponde a um atributo e pode ser um valor at√¥mico ou nulo.
- **Grau**: N√∫mero de atributos de uma rela√ß√£o.
- **Cardinalidade**: N√∫mero de tuplas de uma rela√ß√£o.

Esses conceitos s√£o fundamentais para a **modelagem de dados** no **Modelo Relacional de Dados**, ajudando a descrever as **estruturas** e **quantidade de dados** presentes em um banco de dados relacional.

---

Se precisar de mais exemplos ou detalhes, n√£o hesite em perguntar! üòäüöÄ


### **Relacionamento com outra Tabela**

Agora, vamos adicionar uma tabela relacionada, a **Orders (Pedidos)**:

**Tabela: Orders (Pedidos)**

| **OrderID** | **CustomerID** | **OrderDate** | **TotalAmount** |
|------------|--------------|------------|--------------|
| 101        | 1            | 2024-02-10 | 150.00      |
| 102        | 3            | 2024-02-12 | 200.00      |
| 103        | 2            | 2024-02-15 | 99.90       |
| 104        | 1            | 2024-02-18 | 75.50       |

- **Chave Prim√°ria (PK)**:  
  - **OrderID** na tabela **Orders**.  
  - **CustomerID** na tabela **Customers**.  

- **Chave Estrangeira (FK)**:  
  - **CustomerID** na tabela **Orders**, referenciando **CustomerID** na tabela **Customers**.  

### **Explica√ß√£o do Relacionamento**
- O **CustomerID** na tabela **Orders** indica qual cliente fez cada pedido.  
- Exemplo: O pedido **101** foi feito pelo **CustomerID 1**, que √© **Jo√£o Silva**.  
- Esse relacionamento garante **integridade referencial**, pois um pedido n√£o pode existir sem um cliente associado.

---

Essa estrutura mostra a aplica√ß√£o da **terminologia do Modelo Relacional**, incluindo **rela√ß√µes, tuplas, atributos, dom√≠nios, chaves prim√°ria e estrangeira**.  

Se precisar de mais detalhes ou quiser outro exemplo, √© s√≥ avisar! üòä  

### 5. Aspecto de Manipula√ß√£o  
- O modelo relacional introduziu a √Ålgebra Relacional e o C√°lculo Relacional, permitindo opera√ß√µes como sele√ß√£o, proje√ß√£o, jun√ß√£o e uni√£o de dados.
- Essas opera√ß√µes possibilitam a recupera√ß√£o e manipula√ß√£o eficiente dos dados de forma declarativa.

Os dados armazenados nas rela√ß√µes podem ser manipulados atrav√©s de **operadores da √°lgebra relacional**, que permitem a recupera√ß√£o e modifica√ß√£o eficiente dos dados. Os principais operadores incluem:  
- **Sele√ß√£o (œÉ)**: Filtra linhas que atendem a uma condi√ß√£o espec√≠fica.  
- **Proje√ß√£o (œÄ)**: Seleciona colunas espec√≠ficas de uma tabela.  
- **Jun√ß√£o (‚®ù)**: Combina dados de duas ou mais tabelas com base em um atributo comum.  
- **Uni√£o (‚à™)**: Combina os resultados de duas tabelas semelhantes.  
- **Interse√ß√£o (‚à©)**: Retorna os registros comuns entre duas tabelas.  
- **Diferen√ßa (-)**: Retorna os registros que est√£o em uma tabela, mas n√£o em outra.  

# Opera√ß√µes da √Ålgebra Relacional

As opera√ß√µes da √°lgebra relacional permitem a manipula√ß√£o eficiente de dados em um banco de dados relacional. A seguir, est√£o as principais opera√ß√µes com exemplos:

---

### 1. **Sele√ß√£o (œÉ)**
A opera√ß√£o de **sele√ß√£o** filtra as linhas que atendem a uma condi√ß√£o espec√≠fica.

#### **Sintaxe**:  
\[
\sigma_{\text{condi√ß√£o}}(R)
\]

#### **Exemplo**:

Tabela **Aluno**:

| matricula | nome   | idade | cidade   |
|-----------|--------|-------|----------|
| 1001      | Jo√£o   | 20    | Salvador |
| 1002      | Maria  | 19    | Recife   |
| 1003      | Carlos | 22    | Salvador |

Selecionando os alunos com **idade maior que 20**:

\[
\sigma_{\text{idade} > 20}(Aluno)
\]

**Resultado**:

| matricula | nome   | idade | cidade   |
|-----------|--------|-------|----------|
| 1003      | Carlos | 22    | Salvador |

---

### 2. **Proje√ß√£o (œÄ)**
A opera√ß√£o de **proje√ß√£o** seleciona apenas **colunas espec√≠ficas** de uma tabela.

#### **Sintaxe**:  
\[
\pi_{\text{atributos}}(R)
\]

#### **Exemplo**:

Tabela **Aluno**:

| matricula | nome   | idade | cidade   |
|-----------|--------|-------|----------|
| 1001      | Jo√£o   | 20    | Salvador |
| 1002      | Maria  | 19    | Recife   |
| 1003      | Carlos | 22    | Salvador |

Projetando apenas as **colunas nome** e **idade**:

\[
\pi_{\text{nome, idade}}(Aluno)
\]

**Resultado**:

| nome   | idade |
|--------|-------|
| Jo√£o   | 20    |
| Maria  | 19    |
| Carlos | 22    |

---

### 3. **Jun√ß√£o (‚®ù)**
A opera√ß√£o de **jun√ß√£o** combina os dados de **duas ou mais tabelas** com base em um **atributo comum**.

#### **Sintaxe**:  
\[
R \bowtie_{\text{atributo comum}} S
\]

#### **Exemplo**:

Tabela **Aluno**:

| matricula | nome   | cidade   |
|-----------|--------|----------|
| 1001      | Jo√£o   | Salvador |
| 1002      | Maria  | Recife   |
| 1003      | Carlos | Salvador |

Tabela **Curso**:

| matricula | curso       |
|-----------|-------------|
| 1001      | Matem√°tica  |
| 1002      | F√≠sica      |
| 1004      | Qu√≠mica     |

Jun√ß√£o das tabelas **Aluno** e **Curso** pela **matricula**:

\[
Aluno \bowtie_{\text{matricula}} Curso
\]

**Resultado**:

| matricula | nome   | cidade   | curso      |
|-----------|--------|----------|------------|
| 1001      | Jo√£o   | Salvador | Matem√°tica |
| 1002      | Maria  | Recife   | F√≠sica     |

---

### 4. **Uni√£o (‚à™)**
A opera√ß√£o de **uni√£o** combina os resultados de **duas tabelas** semelhantes, ou seja, ambas com a mesma estrutura (mesmos atributos).

#### **Sintaxe**:  
\[
R \cup S
\]

#### **Exemplo**:

Tabela **Aluno1**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1001      | Jo√£o   | 20    |
| 1002      | Maria  | 19    |

Tabela **Aluno2**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1003      | Carlos | 22    |
| 1004      | Ana    | 21    |

Uni√£o das tabelas **Aluno1** e **Aluno2**:

\[
Aluno1 \cup Aluno2
\]

**Resultado**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1001      | Jo√£o   | 20    |
| 1002      | Maria  | 19    |
| 1003      | Carlos | 22    |
| 1004      | Ana    | 21    |

---

### 5. **Interse√ß√£o (‚à©)**
A opera√ß√£o de **interse√ß√£o** retorna os registros **comuns** entre duas tabelas semelhantes.

#### **Sintaxe**:  
\[
R \cap S
\]

#### **Exemplo**:

Tabela **Aluno1**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1001      | Jo√£o   | 20    |
| 1002      | Maria  | 19    |

Tabela **Aluno2**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1002      | Maria  | 19    |
| 1003      | Carlos | 22    |

Interse√ß√£o das tabelas **Aluno1** e **Aluno2**:

\[
Aluno1 \cap Aluno2
\]

**Resultado**:

| matricula | nome  | idade |
|-----------|-------|-------|
| 1002      | Maria | 19    |

---

### 6. **Diferen√ßa (-)**
A opera√ß√£o de **diferen√ßa** retorna os registros que est√£o **em uma tabela, mas n√£o em outra**.

#### **Sintaxe**:  
\[
R - S
\]

#### **Exemplo**:

Tabela **Aluno1**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1001      | Jo√£o   | 20    |
| 1002      | Maria  | 19    |

Tabela **Aluno2**:

| matricula | nome   | idade |
|-----------|--------|-------|
| 1002      | Maria  | 19    |
| 1003      | Carlos | 22    |

Diferen√ßa entre as tabelas **Aluno1** e **Aluno2**:

\[
Aluno1 - Aluno2
\]

**Resultado**:

| matricula | nome  | idade |
|-----------|-------|-------|
| 1001      | Jo√£o  | 20    |

---

### **Conclus√£o**
As opera√ß√µes da √°lgebra relacional fornecem uma maneira poderosa e declarativa de manipular dados armazenados em um banco de dados relacional. Elas permitem a **sele√ß√£o**, **proje√ß√£o**, **jun√ß√£o**, **uni√£o**, **interse√ß√£o**, e **diferen√ßa** dos dados, tornando poss√≠vel consultar e modificar informa√ß√µes de forma eficiente.

Esses operadores s√£o fundamentais para a constru√ß√£o de consultas complexas em **SQL** e em sistemas de gerenciamento de banco de dados relacionais (SGBDR).

---
Se precisar de mais exemplos ou explica√ß√µes, √© s√≥ avisar! üòä

---

### Refer√™ncias

- [Fasc√≠culo Introdu√ß√£o Banco de Dados](https://educapes.capes.gov.br/bitstream/capes/564494/2/FASCICULO_Introducao_Banco_Dados_30_08.pdf)
- [Univesp - Introdu√ß√£o a Banco de Dados](https://apps.univesp.br/novotec/introducao-a-banco-de-dados/)
